#' Add package code for logging
#'
#' Creates a file in R/ of your package that
#' provides functions for setting up and using a logger
#' with your API.
#'
#' @export
add_logging = function() {
  check_pipework()
  if (has_logging()) {
    warning("It looks like this project already has logging.")
    return()
  }
  cli::cli_h1("Adding logging tools")
  cli::cli_h2("Generating code")
  create_from_template("R", "logger_.R", target_dir = "R")

  cli::cli_h3("Adding dependencies for generated code")
  add_imports(c(
    "jsonlite", "logger", "rlang", "stringr"
  ))
  cli::cli_alert_success("logging can be set up with `setup_logger()`")
}

add_pipe = function() {
  check_package()
  usethis::use_pipe()
}

#' Add API entrypoint to root of project
#'
#' Create a runnable entrypoint at the root of your package.
#'
#' @export
add_entrypoint = function() {
  check_pipework()
  if (has_entrypoint()) {
    warning("It looks like this project already has entrypoint.R")
    return()
  }
  cli::cli_h1("Adding API entrypoint")
  cli::cli_h2("Generating code")
  create_from_template("R", "basic_entry_.R", target_name = "entrypoint.R")
  add_pipe()
}

#' Add default logging hooks to your pipework project
#'
#' Creates a file in your package source R/hooks_.R which
#' contains code to register pre and post route logging hooks
#' to your API.
#'
#' @export
add_hooks = function() {
  check_pipework()
  if (has_hooks()) {
    warning("It looks like this project already has hooks.")
    return()
  }
  if (!has_logging()) {
    cli::cli_alert_info("Standard hooks require logging")
    add_logging()
  }
  cli::cli_h1("Adding hooks")
  cli::cli_h2("Generating code")
  create_from_template("R", "hooks_.R", target_dir = "R")
}

#' Add a new route to your pipework project
#' 
#' Add 3 files, one is the route definition that will be exposed to your
#' plumber router on calling `get_internal_routes()` [from generate_api_.R
#' generated by `lay_pipework()`, stored at inst/extdata/api/routes/]
#' A second file R/api_my_route.R will be generated, this is the wrapper for
#' your core logic for the API. It will receive the request, typically then call
#' another function.
#' The third file is R/<route_name>.R for creating the logic behind the routed
#' request.
#'
#' @param route length 1 character vector, path to your endpoint. This
#'   could be any path relative to the root address of your router. e.g
#'   - "is_alive"
#'   - "test/is_alive"
#' @param method length 1 character vector specifying HTTP method
#' @export
add_route = function(route, 
  method = c("get", "post", "put", "delete", "head", "options", "patch", "use")
) {
  check_pipework()
  method = match.arg(method)
  parts = stringr::str_split(route, "/")[[1]]
  path_length = as.character(length(parts))
  switch(
    path_length,
    "0" = route_error(),
    "1" = base_route(parts, method),
    "2" = file_route(parts, method),
    nested_file_route(parts, method)
  )
}
